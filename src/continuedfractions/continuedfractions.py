__all__ = [
    'ContinuedFraction',
    'continued_fraction_real',
    'continued_fraction_rational',
    'fraction_from_elements',
    'kth_convergent',
]


# -- IMPORTS --

# -- Standard libraries --
import math
import re

from decimal import Decimal
from fractions import Fraction, _RATIONAL_FORMAT
from functools import partial
from types import MappingProxyType
from typing import Any, Generator

# -- 3rd party libraries --

# -- Internal libraries --


def continued_fraction_rational(x: int, y: int, /) -> Generator[int, None, None]:
    """
    Generates the (integer) elements (also called coefficient or terms) of a
    unique, finite, "simple" continued fraction representation of the
    rational fraction `x/y` with numerator `x` and non-zero denominator `y`.

    The number of elements generated minus 1 is called the order of the
    continued fraction, and as the function applies only to rational fractions
    the order will always be finite.

    Negative rational fractions can be represented, but in accordance with
    convention and to ensure uniqueness only the numerator can be negative,
    while the denominator cannot - in case of inputs such as `x/-y`, where
    `x` and `y` are positive integers, the negative sign is "transferred" from
    the denominator `y` to the numerator `x`.

    For a definition of "continued fraction", "element", "order",
    "finite continued fraction", "simple continued fraction", please consult:

        https://en.wikipedia.org/wiki/Continued_fraction
        https://mathcenter.oxford.emory.edu/site/math125/continuedFractions/

    Parameters
    ----------
    x : int
        Numerator of the rational fraction.

    y : int
        Denominator of the rational fraction.

    Yields
    ------
    int
        Elements of a unique, finite "simple" continued fraction representation
        of the given rational fraction `x/y` (where `y` is non-zero).

    Raises
    ------
    ValueError
        If `x` or `y` are not integers.

    ZeroDivisionError
        If `y`, the denominator, is zero.

    Examples
    --------
    A few examples are given below of how this function can be used.

    >>> for e in continued_fraction_rational(649, 200):
    ...     print(e)
    ... 
    3
    4
    12
    4

    >>> list(continued_fraction_rational(415, 93))
    [4, 2, 6, 7]

    >> list(continued_fraction_rational(2.5, 3))
    Traceback (most recent call last):
    ...
    ValueError: `x` and `y` must be integers

    >>> list(continued_fraction_rational(-649, 200))
    [-4, 1, 3, 12, 4]

    >>> list(continued_fraction_rational(123235, 334505))
    [0, 2, 1, 2, 1, 1, 250, 1, 13]

    Notes
    -----
    It is known that every rational number has exactly two finite continued
    fraction representations, one of which has an additional element of `1`
    as its last element. Any such continued fraction can be translated into a
    shorter continued fraction whose last element is 1 + its second last
    element.

    The continued fraction representation generated by this function is the
    shorter version, and is thus unique.

    A continued fraction is called "simple" if all of its fractional terms
    have the numerator `1`, and it is the simple version that is generated by
    the function.
    """
    if not type(x) == type(y) == int:
        raise ValueError("`x` and `y` must be integers")

    if y == 0:
        raise ZeroDivisionError("`y` must be non-zero")

    num, denom = x, y

    if denom < 0:
        num, denom = -num, -denom

    quo, rem = divmod(num, denom)
    yield quo

    while rem > 0:
        num, denom = denom, rem
        quo, rem = divmod(num, denom)
        yield quo


def continued_fraction_real(x: int | float | str, /) -> Generator[int, None, None]:
    """
    Generates the (integer) elements of a "simple" continued fraction
    representation of `x`, which can be either an integer, float or an
    equivalent string representation, except for nans and non-numeric strings.

    As floats are finite precision representations of real numbers, if `x`
    is a float representing a real number with a fractional part containing
    an infinite periodic sequence of digits, or is an irrational number, the
    continued fraction representation of `x`, as given by the elements
    generated by the function, will necessarily be finite, but not necessarily
    unique.

    No attempt is made to raise exceptions or errors directly - if `x` is not
    an `int` or `float`, or is a `nan` or a non-numeric string, either the
    `decimal.Decimal` conversion or the call to `continued_fraction_rational`
    will trigger upstream error(s).

    Parameters
    ----------
    x : int or float or str
        The number to represent as a continued fraction. It can be any `int` or
        `float`, or an equivalent string representation of an `int` or `float`,
        except for nans (`float("nan")`) and non-numeric strings.

    Yields
    ------
    int
        Elements of a unique "simple" continued fraction representation of
        the given `int` or `float`.

    Examples
    --------
    A few examples are given below of how this function can be used.

    >>> list(continued_fraction_real(2/5))
    [0, 2, 2]

    >>> list(continued_fraction_real(2984.0495684))
    [2984, 20, 5, 1, 2, 1, 7, 2, 9, 6, 1, 4]

    >>> list(continued_fraction_real(1/1j))
    Traceback (most recent call last):
    ...
    decimal.InvalidOperation: [<class 'decimal.ConversionSyntax'>]

    >>> list(continued_fraction_real('-1/3'))
    Traceback (most recent call last):
    ...
    decimal.InvalidOperation: [<class 'decimal.ConversionSyntax'>]

    >>> list(continued_fraction_real(-649/200))
    [-4, 1, 3, 12, 4]

    Notes
    -----
    It might be expected that numeric strings expressing rational fractions,
    such as `"1/3"`, would be processed succesfully, but this is not the case,
    as the key step in the function is to use the string representation of `x`
    to construct a `decimal.Decimal` object, which, however, does not treat
    strings such as `"x/y"` where `x` and `y` are integers or floats, as
    numeric.

    See the CPython library source for more information:

    https://github.com/python/cpython/blob/main/Lib/_pydecimal.py#L557

    But actual fractions where the numerator and denominator are `int` or
    `float`, e.g. `-1/4` or `5.6/2`, can be processed successfully.
    """
    num, denum = Decimal(str(x)).as_integer_ratio()

    for elem in continued_fraction_rational(num, denum):
        yield elem


def fraction_from_elements(*elements: int) -> Fraction:
    """
    Returns a `fractions.Fraction` object representing the rational fraction
    constructed from an ordered sequence of the (integer) elements of a
    continued fraction.

    The element sequence must be given as positional arguments, which means
    that if they are contained in an iterable then they must be unpacked
    using the unpacking operator `*`, as described in the examples below.

    Parameters
    ----------
    *elements : int
        A variable-length sequence of integer elements of a continued fraction.

    Returns
    -------
    fractions.Fraction
        A rational fraction constructed from the given sequence of elements of
        a continued fraction.

    Raises
    ------
    ValueError
        If any elements are not integers.

    Examples
    --------
    >>> fraction_from_elements(3, 4, 12, 4)
    Fraction(649, 200)

    >>> fraction_from_elements(-4, 1, 3, 12, 4)
    Fraction(-649, 200)

    >>> fraction_from_elements(4, 2, 6, 7)
    Fraction(415, 93)

    >>> fraction_from_elements(*[4, 2, 6, 7])
    Fraction(415, 93)

    >>> fraction_from_elements(4.5, 2, 6, 7)
    Traceback (most recent call last):
    ...
    ValueError: Continued fraction elements must be integers
    """
    if any(not isinstance(elem, int) for elem in elements):
        raise ValueError("Continued fraction elements must be integers")

    if len(elements) == 1:
        return Fraction(elements[0], 1)

    return elements[0] + Fraction(1, fraction_from_elements(*elements[1:]))


def kth_convergent(*elements: int, k: int = 1) -> Fraction:
    """
    Returns a `fractions.Fraction` object representing the `k`-th convergent of
    a (finite) continued fraction given by an ordered sequence of its (integer)
    elements.
    
    The integer `k` is called the order of the convergent, and a continued
    fraction of order `n` has exactly `n + 1` convergents of orders `0`, `1`,
    ... `n`.

    Each convergent has its own continued fraction representation, which occurs
    as a partial sum in the continued fraction representation of the number
    represented by the continued fraction given by the element sequence.

    It is assumed that `k` < the number of elements, otherwise a `ValueError`
    is raised.

    Parameters
    ----------
    *elements : int
        A variable-length sequence of integer elements of a continued fraction.

    k : int, default=1
        The order of the convergent.

    Returns
    -------
    fractions.Fraction
        A rational fraction constructed from the given sequence of elements of
        a continued fraction, representing the `k`-order convergent of a
        (finite) continued fraction represented by the given element sequence.

    Raises
    ------
    ValueError
        If `k` < the number of elements.

    Examples
    --------
    >>> kth_convergent(3, 4, 12, 4, k=0)
    Fraction(3, 1)

    >>> kth_convergent(3, 4, 12, 4, k=1)
    Fraction(13, 4)

    >>> kth_convergent(3, 4, 12, 4, k=2)
    Fraction(159, 49)

    >>> kth_convergent(3, 4, 12, 4, k=3)
    Fraction(649, 200)

    >>> kth_convergent(3, 4, 12, 4, k=-1)
    Traceback (most recent call last):
    ...
    ValueError: `k` must be a non-negative integer less than the number of elements of the continued fraction

    >>> kth_convergent(3, 4, 12, 4, k=4)
    Traceback (most recent call last):
    ...
    ValueError: `k` must be a non-negative integer less than the number of elements of the continued fraction
    """
    if not isinstance(k, int) or k < 0 or k >= len(elements):
        raise ValueError(
            "`k` must be a non-negative integer less than the number of "
            "elements of the continued fraction"
        )

    return fraction_from_elements(*elements[:k + 1])


class ContinuedFraction(Fraction):
    """
    A simple implementation of continued fractions as Python objects and
    instances of the standard library ``fractions.Fraction`` class, with
    various properties for the continued fraction, including its elements
    (or coefficients), the order, convergents, segments, and remainders.

    Attributes
    ----------
    elements : tuple[int]
        The ordered sequence of elements of the continued fraction.

    order : int
        The order of the continued fraction, defined as the number of
        elements - 1.

    convergents : types.MappingProxyType[int, Fraction]
        An immutable map of all the `k`-order convergents of the continued
        fraction, keyed by `k`.

    Methods
    -------
    segment(k: int)
        The `k`th segment of the continued fraction, defined as the continued
        fraction given by its `k`-order convergent, whose elements consist of
        the first `k + 1` two elements of the original continued fraction.

    remainder(k: int)
        The `k`th remainder of the continued fraction, defined as the continued
        fraction given by the difference between the original continued
        fraction and its `(k - 1)`-order convergent (equivalently, the
        `(k - 1)` order segment, as defined above).

    mediant(other: Fraction)
        The continued fraction of the rational number formed by taking the
        pairwise sum of the numerators and denominators of the original
        continued fraction and a second fraction (`other`). The resulting
        fraction has the property that its value lies between the two
        constituents.

    Examples
    --------
    Construct the continued fraction for the rational `649/200`.

    >>> cf = ContinuedFraction(649, 200)
    >>> cf
    ContinuedFraction(649, 200)

    Inspect the elements, order, convergents, segments and remainders

    >>> cf.elements
    (3, 4, 12, 4)
    >>> cf.order
    3
    >>> cf.convergents
    mappingproxy({0: Fraction(3, 1), 1: Fraction(13, 4), 2: Fraction(159, 49), 3: Fraction(649, 200)})
    >>> cf.segment(1)
    ContinuedFraction(13, 4)
    >>> cf.remainder(1)
    ContinuedFraction(200, 49)

    Check some properties of the segments and remainders

    >>> assert cf.remainder(1) == 1 / (cf - cf.convergents[0])

    Construct continued fractions from element sequences.

    >>> cf_inverse = ContinuedFraction.from_elements(0, 3, 4, 12, 4)
    >>> cf_inverse
    ContinuedFraction(200, 649)
    >>> assert cf_inverse == 1/cf
    >>> assert cf * cf_inverse == 1
    >>> cf_negative_inverse = ContinuedFraction.from_elements(-1, 1, 2, 4, 12, 4)
    >>> cf_negative_inverse
    ContinuedFraction(-200, 649)
    >>> assert cf_negative_inverse == -1/cf
    >>> assert cf * cf_negative_inverse == -1
    """

    # Class attribute to store an error message for input errors
    __valid_inputs_msg__ = (
        "Only single integers, non-nan floats, numeric strings, \n"
        "`fractions.Fraction`, or `decimal.Decimal` objects; or two \n"
        "integers or two `fractions.Fraction` objects or a pairwise \n"
        "combination of these, are valid."
    )

    @classmethod
    def validate(cls, *args: int | float | str | Fraction | Decimal, **kwargs: Any) -> None:
        """
        Checks whether the arguments are one of the following types:

        * a single integer or a non-nan float
        * a single numeric string
        * a single `fractions.Fraction` or `decimal.Decimal` object
        * two integers or `fractions.Fraction` objects, or a combination of an
          integer and a `fractions.Fraction` object, representing the numerator
          and non-zero denominator of a rational fraction

        Parameters
        ----------
        *args: int or float or str or fractions.Fraction or decimal.Decimal
            Arguments of the type described above.

        Raises
        ------
        ValueError
            If validation fails.

        Notes
        -----
        To avoid recursion errors validation excludes `ContinuedFraction`
        instances, and for the same reason convergents of a
        `ContinuedFraction` instance are given as `fractions.Fraction`
        instances.

        Examples
        --------
        >>> ContinuedFraction.validate(100)
        >>> ContinuedFraction.validate(3, -2)

        >>> ContinuedFraction.validate(1, -2.0)
        Traceback (most recent call last):
        ...
        ValueError: Only single integers, non-nan floats, numeric strings, 
        `fractions.Fraction`, or `decimal.Decimal` objects; or two 
        integers or two `fractions.Fraction` objects or a pairwise 
        combination of these, are valid.

        >>> ContinuedFraction.validate(-.123456789)
        >>> ContinuedFraction.validate('-.123456789')
        >>> ContinuedFraction.validate('-649/200')
        >>> ContinuedFraction.validate(-3/2)

        >>> ContinuedFraction.validate(.3, -2)
        Traceback (most recent call last):
        ...
        ValueError: Only single integers, non-nan floats, numeric strings, 
        `fractions.Fraction`, or `decimal.Decimal` objects; or two 
        integers or two `fractions.Fraction` objects or a pairwise 
        combination of these, are valid.

        >>> ContinuedFraction.validate(Fraction(-415, 93))
        >>> ContinuedFraction.validate(Decimal('12345.6789'))
        >>> ContinuedFraction.validate(Decimal(12345.6789))

        >>> ContinuedFraction.validate(Fraction(3, 2), 2.5)
        Traceback (most recent call last):
        ...
        ValueError: Only single integers, non-nan floats, numeric strings, 
        `fractions.Fraction`, or `decimal.Decimal` objects; or two 
        integers or two `fractions.Fraction` objects or a pairwise 
        combination of these, are valid.
        """
        if len(args) not in [1, 2]:
            raise ValueError(cls.__valid_inputs_msg__)

        if (
            len(args) == 1 and
            not set(map(type, args)).issubset(
                [int, float, str, Fraction, Decimal]
            )
        ):
            raise ValueError(cls.__valid_inputs_msg__)

        if any(type(arg) == float and math.isnan(arg) for arg in args):
            raise ValueError(cls.__valid_inputs_msg__)

        if len(args) == 1 and type(args[0]) == str and not _RATIONAL_FORMAT.match(args[0]):
            raise ValueError(cls.__valid_inputs_msg__)

        if len(args) == 2 and not set(map(type, args)).issubset([int, Fraction]):
            raise ValueError(cls.__valid_inputs_msg__)

    def __new__(cls, *args:  int | float | str | Fraction | Decimal, **kwargs: Any) -> Fraction:
        """
        Creates instances of this class, which represent finite, simple
        continued fractions.

        Arguments must be one of the following types:

        * a single integer or a non-nan float
        * a single numeric string
        * a single `fractions.Fraction` or `decimal.Decimal` object
        * two integers or `fractions.Fraction` objects, or a combination of an
          integer and a `fractions.Fraction` object, representing the numerator
          and non-zero denominator of a rational fraction

        Parameters
        ----------
        *args: int or float or str or fractions.Fraction or decimal.Decimal
            Arguments of the type described above.

        **kwargs
            Any valid keyword arguments for the superclass
            `fractions.Fraction`.

        Returns
        -------
        ContinuedFraction
            A new instance of `ContinuedFraction`, but not yet initialised with
            the class-specific attributes and properties.

        Examples
        --------
        >>> ContinuedFraction(100, 2)
        ContinuedFraction(50, 1)

        >>> ContinuedFraction(1, -2.0)
        Traceback (most recent call last):
        ...
        ValueError: Only single integers, non-nan floats, numeric strings, 
        `fractions.Fraction`, or `decimal.Decimal` objects; or two 
        integers or two `fractions.Fraction` objects or a pairwise 
        combination of these, are valid.

        >>> ContinuedFraction('-.123456789')
        ContinuedFraction(-123456789, 1000000000)

        >>> ContinuedFraction(.3, -2)
        Traceback (most recent call last):
        ...
        ValueError: Only single integers, non-nan floats, numeric strings, 
        `fractions.Fraction`, or `decimal.Decimal` objects; or two 
        integers or two `fractions.Fraction` objects or a pairwise 
        combination of these, are valid.

        >>> ContinuedFraction(Fraction(-415, 93))
        ContinuedFraction(-415, 93)
        """
        try:
            cls.validate(*args, **kwargs)
        except ValueError:
            raise

        return super().__new__(cls, *args, **kwargs)

    @classmethod
    def from_elements(cls, *elements: int) -> Fraction:
        """
        Returns a `ContinuedFraction` instance from a sequence of (integer)
        elements of a continued fraction.

        Parameters
        ----------
        *elements: int
            An ordered sequence of elements of a (finite) continued fraction.

        Returns
        -------
        ContinuedFraction
            A new and fully initialised instance of `ContinuedFraction` with
            the given element sequence.

        Examples
        --------
        Constructing a continued fraction for the rational `649/200` using the
        element sequence `(3, 4, 12, 4)`.

        >>> c1 = ContinuedFraction.from_elements(3, 4, 12, 4)
        >>> c1
        ContinuedFraction(649, 200)

        Constructing the continued fraction of the inverse rational `200/649`
        using the element sequence `(0, 3, 4, 12, 4)`.

        >>> c2 = ContinuedFraction.from_elements(0, 3, 4, 12, 4)
        >>> c2
        ContinuedFraction(200, 649)
        """
        return cls(fraction_from_elements(*elements))

    def __init__(self, *args:  int | float | str | Fraction | Decimal, **kwargs: Any) -> None:
        """
        Initialises new `ContinuedFraction` instances with attributes and
        properties for their elements, order, convergents, segments and
        remainders.

        Parameters
        ----------
        *args : int or float or str or fractions.Fraction or decimal.Decimal
            Exactly one argument of the type described above, or two arguments
            which can be either integers or fractions.Fraction objects. Any
            other case, including non-nan floats and non-numeric strings, will
            trigger errors.

        **kwargs
            Any valid keyword arguments for the superclass fractions.Fraction

        Raises
        ------
        ValueError
            If there are arguments that have somehow passed the validation
            check, but do not fall into one of the types described above.

        Examples
        --------
        Construct the continued fraction for the rational `415/93`.

        >>> cf = ContinuedFraction(415, 93)
        >>> cf
        ContinuedFraction(415, 93)

        Inspect the elements, order, convergents, segments and remainders

        >>> cf.elements
        (4, 2, 6, 7)
        >>> cf.order
        3
        >>> cf.convergents
        mappingproxy({0: Fraction(4, 1), 1: Fraction(9, 2), 2: Fraction(58, 13), 3: Fraction(415, 93)})
        >>> cf.segment(0), cf.segment(1), cf.segment(2), cf.segment(3)
        (ContinuedFraction(4, 1), ContinuedFraction(9, 2), ContinuedFraction(58, 13), ContinuedFraction(415, 93))
        >>> cf.remainder(0), cf.remainder(1), cf.remainder(2), cf.remainder(3)
        (ContinuedFraction(415, 93), ContinuedFraction(93, 43), ContinuedFraction(43, 7), ContinuedFraction(7, 1))

        Check some properties of the segments and remainders

        >>> assert cf.remainder(1) == 1 / (cf - cf.convergents[0])
        """
        super().__init__()

        if len(args) == 1 and type(args[0]) == int:
            self._elements = tuple(continued_fraction_rational(args[0], 1))
        elif len(args) == 1 and type(args[0]) == float:
            self._elements = tuple(continued_fraction_real(args[0]))
        elif len(args) == 1 and type(args[0]) == str and _RATIONAL_FORMAT.match(args[0]) and '/' in args[0]:
            self._elements = tuple(continued_fraction_rational(*self.as_integer_ratio()))
        elif len(args) == 1 and type(args[0]) == str and _RATIONAL_FORMAT.match(args[0]) and '/' not in args[0]:
            self._elements = tuple(continued_fraction_real(args[0]))
        elif len(args) == 1 and type(args[0]) in [Fraction, Decimal]:
            self._elements = tuple(continued_fraction_rational(*args[0].as_integer_ratio()))
        elif len(args) == 2 and set(map(type, args)) == set([int]):
            self._elements = tuple(continued_fraction_rational(args[0], args[1]))
        elif len(args) == 2 and set(map(type, args)).issubset([int, Fraction]):
            self._elements = tuple(continued_fraction_rational(*self.as_integer_ratio()))
        else:      # pragma: no cover
            raise ValueError(self.__class__.__valid_inputs_msg__)

        _kth_convergent = partial(kth_convergent, *self._elements)
        self._convergents = MappingProxyType(
            {
                k: _kth_convergent(k=k)
                for k in range(len(self._elements))
            }
        )

    def __add__(self, other: Fraction, /) -> Fraction:
        return self.__class__(super().__add__(other))

    def __radd__(self, other: Fraction, /) -> Fraction:
        return self.__class__(super().__radd__(other))

    def __sub__(self, other: Fraction, /) -> Fraction:
        return self.__class__(super().__sub__(other))

    def __rsub__(self, other: Fraction, /) -> Fraction:
        return self.__class__(super().__rsub__(other))

    def __mul__(self, other: Fraction, /) -> Fraction:
        return self.__class__(super().__mul__(other))

    def __rmul__(self, other: Fraction, /) -> Fraction:
        return self.__class__(super().__rmul__(other))

    def __truediv__(self, other: Fraction, /) -> Fraction:
        return self.__class__(super().__truediv__(other))

    def __rtruediv__(self, other: Fraction, /) -> Fraction:
        return self.__class__(super().__rtruediv__(other))

    def __floordiv__(self, other: Fraction, /) -> Fraction:
        return self.__class__(super().__floordiv__(other))

    def __rfloordiv__(self, other: Fraction, /) -> Fraction:
        return self.__class__(super().__rfloordiv__(other))

    def __divmod__(self, other: Fraction, /) -> Fraction:
        quo, rem = super().__divmod__(other)

        return self.__class__(quo), self.__class__(rem)

    def __rdivmod__(self, other: Fraction, /) -> Fraction:
        quo, rem = super().__rdivmod__(other)
        
        return self.__class__(quo), self.__class__(rem)

    def __pow__(self, other: Fraction, /) -> Fraction:
        return self.__class__(super().__pow__(other))

    def __rpow__(self, other: Fraction, /) -> Fraction:
        return self.__class__(Fraction(other).__pow__(self))

    def __pos__(self) -> Fraction:
        return self.__class__(super().__pos__())

    def __neg__(self) -> Fraction:
        return self.__class__(super().__neg__())

    def __abs__(self) -> Fraction:
        return self.__class__(super().__abs__())

    @property
    def elements(self) -> tuple[int]:
        """
        Property: the element sequence of the continued fraction.

        Returns
        -------
        tuple[int]
            The element sequence of the continued fraction.

        Examples
        --------
        >>> cf = ContinuedFraction('.12345')
        >>> cf
        ContinuedFraction(2469, 20000)
        >>> cf.elements
        (0, 8, 9, 1, 21, 1, 1, 5)
        """
        return self._elements

    @property
    def order(self) -> int:
        """
        Property: the order of the continued fraction, which is the number
                  of its elements + `1`.

        Returns
        -------
        int
            The order of the continued fraction, which is the number of its
            elements + `1`.

        Examples
        --------
        >>> cf = ContinuedFraction('.12345')
        >>> cf
        ContinuedFraction(2469, 20000)
        >>> cf.order
        7
        """
        return len(self._elements[1:])

    @property
    def convergents(self) -> MappingProxyType[int, Fraction]:
        """
        Property: the map of all convergents of the continued fraction, keyed
                  by the orders `0`,`1`,...,`n`, where `n` is the order of
                  the continued fraction.

        Returns
        -------
        types.MappingProxyType[int, fractions.Fraction]
            The map of all convergents of the continued fraction, keyed
            by their orders.

        Examples
        --------
        >>> cf = ContinuedFraction('.12345')
        >>> cf
        ContinuedFraction(2469, 20000)
        >>> cf.convergents
        mappingproxy({0: Fraction(0, 1), 1: Fraction(1, 8), 2: Fraction(9, 73), 3: Fraction(10, 81), 4: Fraction(219, 1774), 5: Fraction(229, 1855), 6: Fraction(448, 3629), 7: Fraction(2469, 20000)})
        """
        return self._convergents

    def segment(self, k: int, /) -> Fraction:
        """
        The `k`th segment of the continued fraction, defined as the continued
        fraction given by its `k`-order convergent, whose elements consist of
        the first `k + 1` two elements of the original continued fraction.

        Parameters
        ----------
        k : int
            The index of the segment, as described above.

        Returns
        -------
        ContinuedFraction
            A new `ContinuedFraction` instance representing the `k`th segment
            of the original continued fraction, as described above.

        Examples
        --------
        >>> cf = ContinuedFraction('.12345')
        >>> cf
        ContinuedFraction(2469, 20000)
        >>> cf.segment(2)
        ContinuedFraction(9, 73)
        """
        return self.__class__.from_elements(*self._elements[:k + 1])

    def remainder(self, k: int, /) -> Fraction:
        """
        The `k`th remainder of the continued fraction, defined as the continued
        fraction given by the difference between the original continued
        fraction and its `(k - 1)`-order convergent (equivalently, the
        `(k - 1)`-order segment, as defined above).

        Parameters
        ----------
        k : int
            The index of the remainder, as described above.

        Returns
        -------
        ContinuedFraction
            A new `ContinuedFraction` instance representing the `k`th remainder
            of the original continued fraction, as described above.

        Examples
        --------
        >>> cf = ContinuedFraction('.12345')
        >>> cf
        ContinuedFraction(2469, 20000)
        >>> cf.remainder(2)
        ContinuedFraction(2469, 248)
        """
        return self.__class__.from_elements(*self._elements[k:])

    def mediant(self, other: Fraction) -> Fraction:
        """
        The continued fraction of the rational number formed by taking the
        pairwise sum of the numerators and denominators of the original
        continued fraction and a second fraction (`other`). The resulting
        fraction has the property that its value lies between its two
        constituents.        

        Parameters
        ----------
        other : fractions.Fraction or ContinuedFraction
            The second fraction to use to calculate the mediant with the
            first.

        Returns
        -------
        ContinuedFraction
            The mediant of the original and the second fractions, as a
            `ContinuedFraction` instance.

        Examples
        --------
        >>> cf = ContinuedFraction('.12345')
        >>> cf
        ContinuedFraction(2469, 20000)
        >>> cf.mediant(Fraction('.1235'))
        ContinuedFraction(679, 5500)
        """
        return self.__class__(
            self.numerator + other.numerator,
            self.denominator + other.denominator
        )


if __name__ == "__main__":      # pragma: no cover
    # Doctest the module from the project root using
    #
    #     python -m doctest -v src/continuedfractions/continuedfractions.py
    #
    import doctest
    doctest.testmod()
